<!DOCTYPE html><html><head><script type="text/javascript">
(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(d){}};this.tick("start",null,a)}var a;window.performance&&(a=window.performance.timing);var f=a?new e(a.responseStart):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart,d=a.responseStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();})()
</script><script type="text/javascript">var KX_timer = new window.jstiming.Timer(); KX_timer.name = 'published';</script><title>Go 1.1 Function Calls</title><link rel="shortcut icon" href="https://ssl.gstatic.com/docs/documents/images/kix-favicon6.ico"><style type="text/css">
      body {
        font-family: arial, sans, sans-serif;
        margin: 0;
      }

      iframe {
        border: 0;
        frameborder: 0;
        height: 100%;
        width: 100%;
      }

      #header, #footer {
        background: #f0f0f0;
        padding: 10px 10px;
      }

      #header {
        border-bottom: 1px #ccc solid;
      }

      #footer {
        border-top: 1px #ccc solid;
        border-bottom: 1px #ccc solid;
        font-size: 13;
      }

      #contents {
        margin: 6px;
      }

      .dash {
        padding: 0 6px;
      }
    </style></head><body><div id="header">Go 1.1 Function Calls</div><div id="contents"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=lhDjYqiy3mZ0x6ROQEUoUw');.lst-kix_g9cdgdh114qy-1>li:before{content:"\0025cb  "}.lst-kix_b4ulw0xdonya-7>li:before{content:"\0025cb  "}.lst-kix_b4ulw0xdonya-5>li:before{content:"\0025a0  "}.lst-kix_zal5b0d78t96-2>li:before{content:"\0025a0  "}.lst-kix_zal5b0d78t96-7>li:before{content:"\0025cb  "}.lst-kix_zal5b0d78t96-6>li:before{content:"\0025cf  "}.lst-kix_zal5b0d78t96-0>li:before{content:"\0025cf  "}.lst-kix_b4ulw0xdonya-8>li:before{content:"\0025a0  "}.lst-kix_zal5b0d78t96-1>li:before{content:"\0025cb  "}.lst-kix_g9cdgdh114qy-3>li:before{content:"\0025cf  "}.lst-kix_g9cdgdh114qy-6>li:before{content:"\0025cf  "}.lst-kix_zal5b0d78t96-3>li:before{content:"\0025cf  "}.lst-kix_b4ulw0xdonya-1>li:before{content:"\0025cb  "}.lst-kix_g9cdgdh114qy-8>li:before{content:"\0025a0  "}ul.lst-kix_zal5b0d78t96-6{list-style-type:none}ul.lst-kix_g9cdgdh114qy-7{list-style-type:none}ul.lst-kix_g9cdgdh114qy-8{list-style-type:none}ul.lst-kix_zal5b0d78t96-5{list-style-type:none}.lst-kix_b4ulw0xdonya-3>li:before{content:"\0025cf  "}ul.lst-kix_g9cdgdh114qy-5{list-style-type:none}ul.lst-kix_zal5b0d78t96-4{list-style-type:none}.lst-kix_g9cdgdh114qy-2>li:before{content:"\0025a0  "}ul.lst-kix_g9cdgdh114qy-6{list-style-type:none}ul.lst-kix_zal5b0d78t96-3{list-style-type:none}.lst-kix_b4ulw0xdonya-4>li:before{content:"\0025cb  "}ul.lst-kix_zal5b0d78t96-2{list-style-type:none}ul.lst-kix_zal5b0d78t96-1{list-style-type:none}.lst-kix_g9cdgdh114qy-5>li:before{content:"\0025a0  "}ul.lst-kix_zal5b0d78t96-0{list-style-type:none}ul.lst-kix_g9cdgdh114qy-0{list-style-type:none}.lst-kix_b4ulw0xdonya-0>li:before{content:"\0025cf  "}ul.lst-kix_g9cdgdh114qy-3{list-style-type:none}.lst-kix_g9cdgdh114qy-4>li:before{content:"\0025cb  "}ul.lst-kix_g9cdgdh114qy-4{list-style-type:none}ul.lst-kix_g9cdgdh114qy-1{list-style-type:none}ul.lst-kix_g9cdgdh114qy-2{list-style-type:none}.lst-kix_b4ulw0xdonya-6>li:before{content:"\0025cf  "}.lst-kix_zal5b0d78t96-5>li:before{content:"\0025a0  "}.lst-kix_b4ulw0xdonya-2>li:before{content:"\0025a0  "}ul.lst-kix_zal5b0d78t96-7{list-style-type:none}ul.lst-kix_zal5b0d78t96-8{list-style-type:none}.lst-kix_zal5b0d78t96-8>li:before{content:"\0025a0  "}ul.lst-kix_b4ulw0xdonya-2{list-style-type:none}ul.lst-kix_b4ulw0xdonya-3{list-style-type:none}ul.lst-kix_b4ulw0xdonya-0{list-style-type:none}ul.lst-kix_b4ulw0xdonya-1{list-style-type:none}.lst-kix_zal5b0d78t96-4>li:before{content:"\0025cb  "}ul.lst-kix_b4ulw0xdonya-8{list-style-type:none}.lst-kix_g9cdgdh114qy-7>li:before{content:"\0025cb  "}.lst-kix_g9cdgdh114qy-0>li:before{content:"\0025cf  "}ul.lst-kix_b4ulw0xdonya-6{list-style-type:none}ul.lst-kix_b4ulw0xdonya-7{list-style-type:none}ul.lst-kix_b4ulw0xdonya-4{list-style-type:none}ul.lst-kix_b4ulw0xdonya-5{list-style-type:none}ol{margin:0;padding:0}.c12{max-width:468pt;background-color:#ffffff;padding:72pt 72pt 72pt 72pt}.c2{height:11pt;direction:ltr}.c1{direction:ltr;margin-left:36pt}.c10{margin:0;padding:0}.c7{padding-left:0pt}.c9{font-style:italic}.c8{font-weight:bold}.c4{direction:ltr}.c0{font-family:"Consolas"}.c5{font-size:9pt}.c11{text-align:center}.c6{margin-left:36pt}.c3{text-align:left}.title{padding-top:0pt;line-height:1.15;text-align:left;color:#000000;font-size:11pt;font-family:"Arial";padding-bottom:0pt}.subtitle{padding-top:0pt;line-height:1.15;text-align:left;color:#000000;font-size:11pt;font-family:"Arial";padding-bottom:0pt}li{color:#000000;font-size:11pt;font-family:"Arial"}p{color:#000000;font-size:11pt;margin:0;font-family:"Arial"}h1{padding-top:0pt;line-height:1.15;text-align:left;color:#000000;font-size:18pt;font-family:"Arial";padding-bottom:0pt}h2{padding-top:0pt;line-height:1.15;text-align:left;color:#000000;font-size:14pt;font-family:"Arial";padding-bottom:0pt}h3{padding-top:0pt;line-height:1.15;text-align:left;color:#666666;font-size:12pt;font-family:"Arial";padding-bottom:0pt}h4{padding-top:0pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:11pt;font-family:"Arial";padding-bottom:0pt}h5{padding-top:0pt;line-height:1.15;text-align:left;color:#666666;font-size:10pt;font-family:"Arial";padding-bottom:0pt}h6{padding-top:0pt;line-height:1.15;text-align:left;color:#666666;font-style:italic;font-size:11pt;font-family:"Arial";padding-bottom:0pt}</style><p class="c4 c11"><span class="c8">Go 1.1 Function Calls</span></p><p class="c2"><span></span></p><p class="c4 c11"><span>Russ Cox</span></p><p class="c4 c11"><span>February 2013</span></p><p class="c2"><span></span></p><p class="c4"><span>The Go 1.0 runtime uses dynamic code generation to implement closures. I took this approach primarily out of expedience: it avoided toolchain-wide changes to the representation of function values and to the function calling convention. However, it is clear that in the long term we should not depend on dynamic code generation, since it limits the environments in which Go can run. It also complicates minor parts of the toolchain: the stack trace code has ugly heuristics to handle closures, and the gdb support cannot get past a closure in a stack trace. The canonical solution is to represent a closure as a pair of pointers, one to static code and one to a dynamic context pointer giving access to the captured variables.</span></p><p class="c2"><span></span></p><p class="c4"><span>As part of addressing the dynamic code generation problem for Go 1.1, it is worth taking a broader look at the way Go implements function calls. This document describes the general requirements and the current implementation and then a proposed new implementation that does away with dynamic code generation and at the same time enables receiver-curried method expressions and removes a panic from package reflect. I plan to do this for Go 1.1.</span></p><p class="c2"><span></span></p><p class="c4"><span>This document supersedes the “Alternatives to Dynamic Code Generation in Go” document I circulated in September 2012. </span></p><p class="c2"><span></span></p><p class="c4"><span class="c8">Kinds of Function Calls</span></p><p class="c2"><span></span></p><p class="c4"><span>This document uses the word “function” to mean any block of Go code that can be executed, and it uses the word “call” to mean the mechanism by which a function is invoked. </span></p><p class="c2"><span></span></p><p class="c4"><span>In Go, there are four different kinds of functions:</span></p><p class="c2"><span></span></p><ul class="c10 lst-kix_g9cdgdh114qy-0 start"><li class="c1 c7"><span>top-level func</span></li><li class="c1 c7"><span>method with value receiver </span></li><li class="c1 c7"><span>method with pointer receiver</span></li><li class="c1 c7"><span>func literal</span></li></ul><p class="c2"><span></span></p><p class="c4"><span>And there are five different kinds of calls:</span></p><p class="c2"><span></span></p><ul class="c10 lst-kix_b4ulw0xdonya-0 start"><li class="c1 c7"><span>direct call of top-level func </span></li><li class="c1 c7"><span>direct call of method with value receiver</span></li><li class="c1 c7"><span>direct call of method with pointer receiver</span></li><li class="c1 c7"><span>indirect call of func value</span></li><li class="c1 c7"><span>indirect call of method on interface </span></li></ul><p class="c2"><span></span></p><p class="c4"><span>The following Go program demonstrates all the possible function/call pairings.</span></p><p class="c2"><span></span></p><p class="c1"><span class="c0 c5">package main</span></p><p class="c2 c6"><span class="c0 c5"></span></p><p class="c1"><span class="c0 c5">func TopLevel(x int) {}</span></p><p class="c2 c6"><span class="c0 c5"></span></p><p class="c1"><span class="c0 c5">type Pointer struct{}</span></p><p class="c1"><span class="c0 c5">func (*Pointer) M(int) {}</span></p><p class="c2 c6"><span class="c0 c5"></span></p><p class="c1"><span class="c0 c5">type Value struct{}</span></p><p class="c1"><span class="c0 c5">func (Value) M(int) {}</span></p><p class="c2 c6"><span class="c0 c5"></span></p><p class="c1"><span class="c0 c5">type Interface interface { M(int) }</span></p><p class="c2 c6"><span class="c0 c5"></span></p><p class="c1"><span class="c0 c5">var literal = func(x int) {}</span></p><p class="c2 c6"><span class="c0 c5"></span></p><p class="c1"><span class="c0 c5">func main() {</span></p><p class="c1"><span class="c0 c5">        // direct call of top-level func</span></p><p class="c1"><span class="c0 c5">        TopLevel(1)</span></p><p class="c1"><span class="c0 c5">        </span></p><p class="c1"><span class="c0 c5">        // direct call of method with value receiver (two spellings, but same)</span></p><p class="c1"><span class="c0 c5">        var v Value</span></p><p class="c1"><span class="c0 c5">        v.M(1)</span></p><p class="c1"><span class="c0 c5">        Value.M(v, 1)</span></p><p class="c2 c6"><span class="c0 c5"></span></p><p class="c1"><span class="c0 c5">        // direct call of method with pointer receiver (two spellings, but same)</span></p><p class="c1"><span class="c0 c5">        var p Pointer</span></p><p class="c1"><span class="c0 c5">        (&amp;p).M(1)</span></p><p class="c1"><span class="c0 c5">        (*Pointer).M(&amp;p, 1)</span></p><p class="c1"><span class="c0 c5">        </span></p><p class="c1"><span class="c0 c5">        // indirect call of func value (×4)</span></p><p class="c1"><span class="c0 c5">        f1 := TopLevel</span></p><p class="c1"><span class="c0 c5">        f1(1)</span></p><p class="c1"><span class="c0 c5">        f2 := Value.M</span></p><p class="c1"><span class="c0 c5">        f2(v, 1)</span></p><p class="c1"><span class="c0 c5">        f3 := (*Pointer).M</span></p><p class="c1"><span class="c0 c5">        f3(&amp;p, 1)</span></p><p class="c1"><span class="c0 c5">        f4 := literal</span></p><p class="c1"><span class="c0 c5">        f4(1)</span></p><p class="c2 c6"><span class="c0 c5"></span></p><p class="c1"><span class="c0 c5">        // indirect call of method on interface (×3)</span></p><p class="c1"><span class="c0 c5">        var i Interface</span></p><p class="c1"><span class="c0 c5">        i = v</span></p><p class="c1"><span class="c0 c5">        i.M(1)</span></p><p class="c1"><span class="c0 c5">        i = &amp;v</span></p><p class="c1"><span class="c0 c5">        i.M(1)</span></p><p class="c1"><span class="c0 c5">        i = &amp;p</span></p><p class="c1"><span class="c0 c5">        i.M(1)</span></p><p class="c1"><span class="c0 c5">        Interface.M(i, 1)</span></p><p class="c1"><span class="c0 c5">        Interface.M(v, 1)</span></p><p class="c1"><span class="c0 c5">        Interface.M(&amp;p, 1)</span></p><p class="c1"><span class="c0 c5">}</span></p><p class="c2"><span></span></p><p class="c4"><span>As the program shows, there are ten possible combinations of function and call:</span></p><p class="c2"><span></span></p><ul class="c10 lst-kix_zal5b0d78t96-0 start"><li class="c1 c7"><span>direct call of top-level func /</span></li><li class="c1 c7"><span>direct call of method with value receiver /</span></li><li class="c1 c7"><span>direct call of method with pointer receiver /</span></li><li class="c1 c7"><span>indirect call of func value / set to top-level func</span></li><li class="c1 c7"><span>indirect call of func value / set to value method</span></li><li class="c1 c7"><span>indirect call of func value / set to pointer method</span></li><li class="c1 c7"><span>indirect call of func value / set to func literal</span></li><li class="c1 c7"><span>indirect call of method on interface / containing value with value method</span></li><li class="c1 c7"><span>indirect call of method on interface / containing pointer with value method</span></li><li class="c1 c7"><span>indirect call of method on interface / containing pointer with pointer method</span></li></ul><p class="c2"><span></span></p><p class="c4"><span>In the list, a slash separates what is known at compile time from what is only found out at run time. </span><span>The code generated at compile time for an indirect call cannot depend on the run-time values; instead, some of the indirect cases are handled by generating adapter functions that fit the expectations of the indirect call.</span></p><p class="c2"><span></span></p><p class="c4"><span class="c8">Current Implementation</span></p><p class="c2"><span></span></p><p class="c4"><span>This section describes the current implementation of the possible function calls.</span></p><p class="c2"><span></span></p><p class="c4"><span class="c9">Direct call of top-level func.</span><span> A direct call of a top-level func passes all arguments on the stack, expecting results to occupy the successive stack positions. This matches the calling convention used by the associated C compilers.</span></p><p class="c2"><span></span></p><p class="c4"><span class="c9">Direct call of method</span><span>. In order to use the same generated code for both an indirect call of a func value and for a direct call, the code generated for a method (both value and pointer receivers) is chosen to have the same calling convention as a top-level function with the receiver as a leading argument.</span></p><p class="c2"><span></span></p><p class="c4"><span class="c9">Indirect call of func value.</span><span> An indirect call is treated as identical to a direct call of a top-level func except for the actual CALL or BL instruction: in this case, the func value is treated as containing the address of the code to execute. This choice means that an indirect call to a top-level func dispatches to the same function that the direct call does. As mentioned above, an indirect call of a method dispatches to the direct method function. That leaves an indirect call of a func value set to a func literal.</span></p><p class="c2"><span></span></p><p class="c4"><span>In general a func literal value has two parts: a function that can be generated at compile time, and then some associated hidden arguments that are known at run time when the func literal expression is evaluated and its value saved. In order to match the calling convention expected for an indirect call of a func value, the current implementation uses run time-generated code that supplies the hidden arguments to a compile time-generated function body.</span></p><p class="c2"><span></span></p><p class="c4"><span class="c9">Indirect call of method on interface.</span><span> An interface value is a pair (type, word), where the word can be the typed value stored in the interface, if it fits, or else a pointer to the typed value. An interface method call retrieves from the type the address of the method code to execute and then calls it like an indirect call with the word as a leading argument. If the typed value is itself a pointer and the method is a pointer method, then the calling convention matches that of the direct and indirect calls above, so that the call can dispatch to the same function they use. If the typed value is a non-pointer of exactly one word in size and the method is a value method, the same optimization applies. Otherwise, for the remaining cases, namely a value method invoked on a typed pointer or non-pointer, the code used for other call contexts does not have the same calling convention. An adapter function must be generated at compile time, and the address of that adapter function stored in the method table consulted during the interface call. For example, the Value type above would use in its method table an adapter function like:</span></p><p class="c2"><span></span></p><p class="c1"><span class="c0">func Value.M·i(word uintptr, x int) {</span></p><p class="c1"><span class="c0">        v := *(*Value)(unsafe.Pointer(&amp;word))</span></p><p class="c1"><span class="c0">        v.M(x)</span></p><p class="c1"><span class="c0">}</span></p><p class="c2"><span></span></p><p class="c4"><span>If a Value exceeded one word in size (instead of, in this case, being smaller than one word), the adapter would look the same but omit the &amp; in &amp;word.</span></p><p class="c2"><span></span></p><p class="c4"><span class="c8">Problems with the Current Implementation</span></p><p class="c2"><span></span></p><p class="c4"><span>The current implementation is elegant, entirely dictated by three choices: (1) a direct call should match C’s conventions, (2) an indirect call should dispatch to the same code as a direct call, and (3) an interface call should dispatch to the same code as a direct call in the case of a pointer with pointer methods. However, there are three shortcomings.</span></p><p class="c2"><span></span></p><p class="c4"><span class="c9">Run-time code generation</span><span>. In order to make func literal values fit the model for indirect calls, the current implementation uses run-time code generation to implement the capturing of local variables. In contexts such as embedded or sandboxed systems, run-time code generation can be expensive or impossible. Go cannot depend on it. The usual solution is to make func values two words, one code pointer referring to compile time-generated code and one data pointer referring to captured local variables.</span></p><p class="c2"><span></span></p><p class="c4"><span class="c9">Method Values. </span><span>In discussions over a year ago, we reached consensus on what the meaning of method values would be if we added them to the language. They would look like:</span></p><p class="c2"><span></span></p><p class="c1"><span class="c0">var r io.Reader</span></p><p class="c1"><span class="c0">f := r.Read  // f has type func([]byte) (int, error)</span></p><p class="c1"><span class="c0">n, err := f(p)</span></p><p class="c2"><span></span></p><p class="c4"><span>Even once we reached that agreement, I did not bother to send out a spec change, because the implementation of “f := r.Read” would hide the allocation of a closure. It seemed better to force people to write:</span></p><p class="c2"><span></span></p><p class="c1"><span class="c0">f := func(p []byte) (int, error) { return r.Read(p) }</span></p><p class="c2"><span></span></p><p class="c4"><span>and make the closure explicit. Also I was lazy and did not want to implement it. But I have always treated it as a “someday we’ll want to do this.” The fact that “f := r.Read” is disallowed is a common surprise among new programmers. The two-word func value representation makes possible a trivial implementation of “f := r.Read”.</span></p><p class="c2"><span></span></p><p class="c4"><span class="c9">Reflect</span><span>. In reflection, v.Method(i) returns a Value corresponding to the i’th method of v with the receiver v pre-bound. For example, assuming the i’th method is named F,</span></p><p class="c1"><span class="c0">v.Method(i).Call(ValueOf(x), ValueOf(y))</span></p><p class="c4"><span>is the reflect equivalent of v.F(x, y). The fact that Method and Call are two different steps means that v.Method(i) by itself must evaluate to something. Today it evaluates a reflect.Value that can be used in Call and have its Type inspected. However, the Interface method, as in</span></p><p class="c1"><span class="c0">v.Method(i).Interface()</span></p><p class="c4"><span>panics, because there is no Go value to return in the interface{}.</span></p><p class="c2"><span></span></p><p class="c4"><span>The two-word func value representation makes it trivial to create a true method value here with v pre-bound, just as it makes it trivial to create one in the “f := r.Read” case. So the Interface call would not need to panic anymore. (It is important to fix both of these at the same time; if we fix reflect but disallow “f := r.Read” people will resort to using reflect to work around the deficiency in the language proper, a situation we should avoid.)</span></p><p class="c2"><span></span></p><p class="c4"><span class="c8">New Implementation</span></p><p class="c2"><span></span></p><p class="c4"><span>We propose a new implementation that changes only the “indirect call of func value” mechanism. All other call details remain unchanged.</span></p><p class="c2"><span></span></p><p class="c4"><span>The new implementation avoids the need for runtime code generation by making a func value a pointer to a variable-sized block of data memory, in which the first word holds a code pointer and the remainder holds additional data that can be used by the called code. This diagram shows the memory layout of a func variable in the current implementation in grey, with the changes required by the proposed new implementation in black:</span></p><p class="c4 c11"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 400.00px; height: 245.69px;"><img alt="" src="https://docs.google.com/drawings/image?id=sC4IVeEzDyculxBQV4VogLw&amp;rev=109&amp;h=245&amp;w=400&amp;ac=1" style="width: 400.00px; height: 245.69px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4 c3"><span>In the current implementation, the func value holds a pointer to the actual code to be run during a call. The new implementation introduces an indirection through the data block.</span></p><p class="c2 c3"><span></span></p><p class="c4 c3"><span>In the current implementation, a call sequence looked like:</span></p><p class="c2 c3"><span></span></p><p class="c1 c3"><span class="c0">MOV …, R1</span></p><p class="c1 c3"><span class="c0">CALL R1</span></p><p class="c2 c3"><span></span></p><p class="c4 c3"><span>In the new implementation, a call sequence adds an indirection, and it also leaves the indirect block address (that is, the address of the middle box) in a well-known register (R0 here):</span></p><p class="c2 c3"><span></span></p><p class="c1 c3"><span class="c0">MOV …, R0</span></p><p class="c1 c3"><span class="c0">MOV 0(R0), R1</span></p><p class="c1 c3"><span class="c0">CALL R1  </span><span># called code can access “data” using R0</span></p><p class="c2"><span></span></p><p class="c4"><span>Consider each of the possible ways to initialize a Go func value, from the program above:</span></p><p class="c2"><span></span></p><p class="c1"><span class="c0">f1 := TopLevel</span></p><p class="c1"><span class="c0">f1(1)</span></p><p class="c1"><span class="c0">f2 := Value.M</span></p><p class="c1"><span class="c0">f2(v, 1)</span></p><p class="c1"><span class="c0">f3 := (*Pointer).M</span></p><p class="c1"><span class="c0">f3(&amp;p, 1)</span></p><p class="c1"><span class="c0">f4 := literal</span></p><p class="c1"><span class="c0">f4(1)</span></p><p class="c2"><span></span></p><p class="c4"><span>Except when calling a func literal that captures outer local variables, there is no associated data, so the memory layout reduces to:</span></p><p class="c4 c11"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 400.00px; height: 245.69px;"><img alt="" src="https://docs.google.com/drawings/image?id=sKBkBH59mEqftVuP4YhqUXA&amp;rev=13&amp;h=245&amp;w=400&amp;ac=1" style="width: 400.00px; height: 245.69px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4 c3"><span>In this case, the middle box is simply a C function pointer, so the Go func value is simply a pointer to a C function pointer. The extra C function pointer word must be allocated, but the fact of the assignment is known to the compiler ahead of time, so the pointer word can be allocated in read-only data and only once for each function being stored in a func value, no matter how many places in the program do so.</span></p><p class="c2 c3"><span></span></p><p class="c4 c3"><span>That is, the assignment “f := MyFunc” would generate code like:</span></p><p class="c2 c3"><span></span></p><p class="c1 c3"><span class="c0">MOV $MyFunc·f(SB), f1</span></p><p class="c2 c6 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0">DATA MyFunc·f(SB)/8, $MyFunc(SB)</span></p><p class="c1 c3"><span class="c0">GLOBL MyFunc·f(SB), 10, $8</span></p><p class="c2 c3"><span></span></p><p class="c4 c3"><span>The actual store instruction records a pointer to the read-only data MyFunc·f, which itself holds a pointer to the actual code MyFunc. The ·f suffix establishes a separate name space for these indirection words. In the GLOBL declaration, the flag word 10 sets bits 8 (read-only memory) and 2 (duplicate definitions can be merged in the final binary).</span></p><p class="c2 c3"><span></span></p><p class="c4 c3"><span>This applies to all functions without associated data. In the snippet above, f1, f2, f3, and f4 without captured variables all use this pattern.</span></p><p class="c2 c3"><span></span></p><p class="c4 c3"><span>If a func literal (f4) does capture variables, then a larger indirect block must be allocated at run time. The first word points at the compile time-generated function, and the rest of the block holds the pointers to the captured variables. The “runtime.closure” function, called to create a closure, currently allocates memory and then fills in actual machine instructions to produce a code sequence. The new implementation need only allocate memory and copy the necessary code and data pointers into it, little more than filling out a composite literal.</span></p><p class="c2 c3"><span></span></p><p class="c4"><span>Assigning a method expression to a func value, as in “f := r.Read”, will allocate an indirect block containing a pointer to an adapter function and then, as the data, a copy of r. The statement “f := r.Read” then compiles into, approximately:</span></p><p class="c2 c3"><span></span></p><p class="c1"><span class="c0">type funcValue struct {</span></p><p class="c1"><span class="c0">        f func([]byte) (int, error)</span></p><p class="c1"><span class="c0">        r io.Reader</span></p><p class="c1"><span class="c0">}</span></p><p class="c2 c6"><span class="c0"></span></p><p class="c1 c3"><span class="c0">func readAdapter(b []byte) (int, error) {</span></p><p class="c1 c3"><span class="c0">        r := (*io.Reader)(R0+8)</span></p><p class="c1 c3"><span class="c0">        return r.Read(b)</span></p><p class="c1 c3"><span class="c0">}</span></p><p class="c2 c6 c3"><span></span></p><p class="c1 c3"><span class="c0">f := &amp;funcValue{readAdapter, r}</span></p><p class="c2 c3"><span></span></p><p class="c4 c3"><span class="c9">Reflection</span><span>. The fact that a pointer to a C function pointer is a valid Go func value means that reflection can generate a Go func value by using a pointer into its own tables. For example, a concrete type like *bytes.Buffer has an associated method table. Suppose table[0] holds the code address (C function pointer) for (*Buffer).Read, table[1] holds the address for (*Buffer).Write, and so on. When a reflect call like</span><span class="c0"> </span></p><p class="c1"><span class="c0">reflect.TypeOf(new(bytes.Buffer)).Method(0)</span></p><p class="c4 c3"><span>must create a Go func value corresponding to (*Buffer).Read, it can return &amp;table[0] instead of needing to allocate an explicit indirect block.</span></p><p class="c2 c3"><span></span></p><p class="c4 c3"><span>One of the goals of allowing “f := r.Read” was to enable </span></p><p class="c1 c3"><span class="c0">f := reflect.ValueOf(new(bytes.Buffer)).Method(0).Interface()</span></p><p class="c4 c3"><span>to have the same effect; currently it panics in the call to Interface. The obvious implementation is to generate a function like readAdapter above for every method and to record pointers to those functions in the reflection tables. This has the drawback of growing the reflection tables and growing the text segment, by including adapters that will in most cases never be used. Instead, we can include a single adapter for use by reflect no matter what the function. It would need to be written in assembly, and the effect of its use would make the call above generate something like:</span></p><p class="c2 c3"><span></span></p><p class="c1 c3"><span class="c0">typedef struct funcValue funcValue;</span></p><p class="c2 c6 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0">struct funcValue {</span></p><p class="c1 c3"><span class="c0">        void (*adapter)(void);</span></p><p class="c1 c3"><span class="c0">        void (*fn)(void);</span></p><p class="c1 c3"><span class="c0">        uintptr rcvrArgBytes;</span></p><p class="c1 c3"><span class="c0">        uintptr inArgBytes;</span></p><p class="c1 c3"><span class="c0">        uintptr outArgBytes;</span></p><p class="c1 c3"><span class="c0">        byte rcvr[0];</span></p><p class="c1 c3"><span class="c0">}</span></p><p class="c2 c6 c3"><span class="c0"></span></p><p class="c1 c3"><span class="c0">f := malloc(sizeof(funcValue) + sizeof(*bytes.Buffer))</span></p><p class="c1 c3"><span class="c0">f.adapter = adapter</span></p><p class="c1 c3"><span class="c0">f.fn = (*bytes.Buffer).Read;</span></p><p class="c1 c3"><span class="c0">f.rcvrArgBytes = sizeof(*bytes.Buffer);</span></p><p class="c1 c3"><span class="c0">f.inArgBytes = sizeof([]byte)</span></p><p class="c1 c3"><span class="c0">f.outArgBytes = sizeof(int, error);</span></p><p class="c1 c3"><span class="c0">memmove(&amp;f.rcvr, r, sizeof(*bytes.Buffer));</span></p><p class="c2 c3"><span></span></p><p class="c4 c3"><span>and the adapter would need to use the context recorded in funcValue to make a generic function call, similar to (but simpler than) what reflect.Call does today. This would be slightly slower than pre-generating custom adapters, but it avoids the space overheads.</span></p><p class="c2"><span></span></p><p class="c4"><span class="c8">Properties of the New Implementation</span></p><p class="c2"><span></span></p><p class="c4"><span>Compared to the current implementation, the new implementation sacrifices the match between direct calls of Go and C functions. In particular, the runtime has thus far assumed that a Go func(int) and a C void(*)(int) are the same type. The distinction will need to be introduced, in the same way that the runtime must distinguish a Go string from a C char*. The new implementation preserves the other two, more important properties: an indirect call dispatches to the same code as a direct call, and an interface call dispatches to the same code as a direct method call in the case of a pointer with pointer methods.</span></p><p class="c2"><span></span></p><p class="c4"><span>The new implementation introduces a memory load immediately before the indirect call of a func value. It is possible that this will stall indirect CALL instructions somewhat, but this only affects calls using func values, not interface calls.</span></p><p class="c2"><span></span></p><p class="c4"><span>The new implementation preserves the in-memory size of a func value, so code copying func values need not change, and code written in C or assembly with func-valued arguments need not recompute argument frame or local variable offsets. Of course, the func value meaning has changed, even if the size has not, so C or assembly trying to call a Go func value will need adjustment.</span></p><p class="c2"><span></span></p><p class="c4"><span>The new implementation does not grow the memory tables required for run-time reflection. An indirect function word is included only when a statement like “f := MyFunc” is included in the binary; reflection uses a different strategy that avoids allocation but at the same time reuses existing tables.</span></p><p class="c2"><span></span></p><p class="c4"><span class="c8">Backwards Incompatibility</span></p><p class="c2"><span></span></p><p class="c4"><span>Almost no existing code will need to change. The only incompatibility is in C or assembly that calls Go func values. Such code will need to be updated to account for the indirect block.</span></p><p class="c2"><span></span></p><p class="c4"><span>Differences in the way direct-compiled Go code creates func values and the way reflection creates func values means that two func values referring to the same underlying code - even in the absence of closures - may use different pointers to get to it. Since func comparison is disallowed, this change can only break programs using unsafe, and such programs would also break in the presence of shared libraries when using gccgo.</span></p><p class="c2"><span></span></p><p class="c4"><span>It is now impossible for reflect’s Value.Pointer to return a unique identifier for a function. One possibility is to return the address of the indirect block, which would ensure that distinct functions have different “Pointer()”s. Unfortunately, then the result is not useful with runtime.FuncForPC, which some people might currently depend on. Instead, we will make Value.Pointer return the associated code pointer and document that different functions (for example, different instances of the same func literal, or all functions using the generic reflect adapter) may return the same pointer. The only guarantee is that the result of Value.Pointer on a func is zero if and only if the func is nil.</span></p><p class="c2"><span></span></p><p class="c4"><span class="c8">Implementation Plan</span></p><p class="c2"><span></span></p><p class="c4"><span>The implementation can follow these steps. Each step results in a working tree.</span></p><p class="c2"><span></span></p><p class="c4"><span>1. Make the func value an indirect word, keeping run-time code generation. All func values will look like the second picture (no associated data). This will require compiler changes to generate the MyFunc·f words, runtime changes to distinguish C function pointers from Go func values, and reflect changes to understand the new layouts.</span></p><p class="c2"><span></span></p><p class="c4"><span>2. Change the func-literal implementation to save captured pointers in the indirect blocks instead instead of run-time code generation. This is mainly compiler changes, plus deleting the runtime code generation function runtime.closure.</span></p><p class="c2"><span></span></p><p class="c4"><span>3. Change the reflect.MakeFunc implementation to avoid run-time code generation as well (fixes issues 3736, 3738, 4081).</span></p><p class="c2"><span></span></p><p class="c4"><span>4. Delete the closure hacks from traceback routines, possibly other places.</span></p><p class="c2"><span></span></p><p class="c4"><span>5. Add support for “f := r.Read” (fixes issue 2280).</span></p><p class="c2"><span></span></p><p class="c4"><span>6. Make reflect’s v.Method(i).Interface() work (fixes issue 1517).</span></p><p class="c2"><span></span></p></div><div id="footer"><span>Published by <a target="_blank" title="Learn more about Google Drive" href="https://docs.google.com/">Google Drive</a></span><span class="dash">&ndash;</span><a href="https://docs.google.com/abuse?id=1bMwCey-gmqZVTpRax-ESeVuZGmjwbocYs1iHplK-cjo">Report Abuse</a><span class="dash">&ndash;</span><span>Updated automatically every 5 minutes</span></div><script type="text/javascript">
(function(){if(window.jstiming){window.jstiming.a={};window.jstiming.b=1;var e=function(b,a,d){var c=b.t[a],g=b.t.start;if(c&&(g||d))return c=b.t[a][0],void 0!=d?g=d:g=g[0],c-g},n=function(b,a,d){var c="";window.jstiming.srt&&(c+="&srt="+window.jstiming.srt,delete window.jstiming.srt);window.jstiming.pt&&(c+="&tbsrt="+window.jstiming.pt,delete window.jstiming.pt);try{window.external&&window.external.tran?c+="&tran="+window.external.tran:window.gtbExternal&&window.gtbExternal.tran?c+="&tran="+window.gtbExternal.tran():
window.chrome&&window.chrome.csi&&(c+="&tran="+window.chrome.csi().tran)}catch(g){}var f=window.chrome;if(f&&(f=f.loadTimes)){f().wasFetchedViaSpdy&&(c+="&p=s");if(f().wasNpnNegotiated){var c=c+"&npn=1",k=f().npnNegotiatedProtocol;k&&(c+="&npnv="+(encodeURIComponent||escape)(k))}f().wasAlternateProtocolAvailable&&(c+="&apa=1")}var l=b.t,s=l.start,f=[],k=[],h;for(h in l)if("start"!=h&&0!=h.indexOf("_")){var m=l[h][1];m?l[m]&&k.push(h+"."+e(b,h,l[m][0])):s&&f.push(h+"."+e(b,h))}delete l.start;if(a)for(var p in a)c+=
"&"+p+"="+a[p];(a=d)||(a="https:"==document.location.protocol?"https://csi.gstatic.com/csi":"http://csi.gstatic.com/csi");return[a,"?v=3","&s="+(window.jstiming.sn||"_s")+"&action=",b.name,k.length?"&it="+k.join(","):"",c,"&rt=",f.join(",")].join("")};window.jstiming.getReportUri=n;var q=function(b,a,d){b=n(b,a,d);if(!b)return"";a=new Image;var c=window.jstiming.b++;window.jstiming.a[c]=a;a.onload=a.onerror=function(){window.jstiming&&delete window.jstiming.a[c]};a.src=b;a=null;return b};window.jstiming.report=
function(b,a,d){if("prerender"==document.webkitVisibilityState){var c=!1,g=function(){if(!c){a?a.prerender="1":a={prerender:"1"};var f;"prerender"==document.webkitVisibilityState?f=!1:(q(b,a,d),f=!0);f&&(c=!0,document.removeEventListener("webkitvisibilitychange",g,!1))}};document.addEventListener("webkitvisibilitychange",g,!1);return""}return q(b,a,d)};window.jstiming.reportDone=function(b){if(window.jstiming.b<=(b||1))return!1;for(var a in window.jstiming.a)return!1;return!0};var r=function(b,a,
d,c){return 0<d?(c?b.tick(a,c,d):b.tick(a,"",d),!0):!1};window.jstiming.getNavTiming=function(b){if(window.performance&&window.performance.timing){var a=window.performance.timing;r(b,"_dns",a.domainLookupStart)&&r(b,"dns_",a.domainLookupEnd,"_dns");r(b,"_con",a.connectStart)&&r(b,"con_",a.connectEnd,"_con");r(b,"_req",a.requestStart)&&r(b,"req_",a.responseStart,"_req");r(b,"_rcv",a.responseStart)&&r(b,"rcv_",a.responseEnd,"_rcv");if(r(b,"_ns",a.navigationStart)){r(b,"ntsrt_",a.responseStart,"_ns");
r(b,"nsfs_",a.fetchStart,"_ns");var d=window.external&&window.external.startE;!d&&window.chrome&&window.chrome.csi&&(d=Math.floor(window.chrome.csi().startE));d&&(r(b,"_se",d),r(b,"sens_",a.navigationStart,"_se"));r(b,"ntplt0_",a.loadEventStart,"_ns");r(b,"ntplt1_",a.loadEventEnd,"_ns")}}}};})()
</script><script type="text/javascript">KX_timer.tick('tl'); if (document.location.protocol == 'https:') {window.jstiming.report(KX_timer, undefined , 'https://gg.google.com/csi');} else {window.jstiming.report(KX_timer);}</script></body></html>